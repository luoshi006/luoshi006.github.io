var suggestions=document.getElementById('suggestions'),userinput=document.getElementById('userinput');document.addEventListener('keydown',inputFocus);function inputFocus(a){a.keyCode===191&&(a.preventDefault(),userinput.focus()),a.keyCode===27&&(userinput.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(b){const d=suggestions.querySelectorAll('a'),e=[...d],a=e.indexOf(document.activeElement);let c=0;b.keyCode===38?(b.preventDefault(),c=a>0?a-1:0,d[c].focus()):b.keyCode===40&&(b.preventDefault(),c=a+1<e.length?a+1:a,d[c].focus())}(function(){var b=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:'id',store:["href","title","description"],index:["title","description","content"]}});b.add({id:0,href:"https://luoshi006.github.io/docs/learning/introduction/",title:"Introduction",description:"",content:'\u003ch2 id="learning"\u003eLearning\u003c/h2\u003e\n\u003cp\u003e记录学习过程\u0026hellip;.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href="/docs/learning/traj_planning/20210903_traj_planning"\u003eTraj Planning\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/learning/traj_planning/20210903_rt_traj_optimization_for_racing"\u003eReal-time Trajectory Optimization for Autonomous Vehicle Racing\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e一篇本科论文，从汽车模型开始，介绍了怎么建模，构建 QP 问题，线性化处理；比较全面，且有代码示例；\u003c/li\u003e\n\u003cli\u003e因为里面涉及到比较多 \u003cstrong\u003e凸优化\u003c/strong\u003e 的知识，所以深入阅读有门槛；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/learning/traj_planning/20210916_optimal_traj_in_frenet_frame"\u003eOptimal Trajectory Generation for Dynamic Street Scenarios in a Frenet Frame\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e自动驾驶经典论文，介绍了 \u003cstrong\u003eFrenet 坐标系\u003c/strong\u003e 下的轨迹生成，并根据代价选择最优路径；\u003c/li\u003e\n\u003cli\u003e基于采样的方法实现，涉及一些多项式拟合的东西；\u003c/li\u003e\n\u003cli\u003e论文不是很友好，但代码比较清晰；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003espline\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/learning/spline/20210917_cubic_spline"\u003ecubic_spline\u003c/a\u003e 简单描述了常见的 \u003cstrong\u003e三次样条曲线\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n'}).add({id:1,href:"https://luoshi006.github.io/docs/learning/traj_planning/20210903_traj_planning/",title:"Traj Planning",description:"",content:'\u003chr\u003e\n\u003ch2 id="traj-planning"\u003eTraj Planning\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/learning/traj_planning/20210903_rt_traj_optimization_for_racing"\u003eReal-time Trajectory Optimization for Autonomous Vehicle Racing\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e一篇本科论文，从汽车模型开始，介绍了怎么建模，构建 QP 问题，线性化处理；比较全面，且有代码示例；\u003c/li\u003e\n\u003cli\u003e因为里面涉及到比较多 \u003cstrong\u003e凸优化\u003c/strong\u003e 的知识，所以深入阅读有门槛；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href="/docs/learning/traj_planning/20210916_optimal_traj_in_frenet_frame"\u003eOptimal Trajectory Generation for Dynamic Street Scenarios in a Frenet Frame\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e自动驾驶经典论文，介绍了 \u003cstrong\u003eFrenet 坐标系\u003c/strong\u003e 下的轨迹生成，并根据代价选择最优路径；\u003c/li\u003e\n\u003cli\u003e基于采样的方法实现，涉及一些多项式拟合的东西；\u003c/li\u003e\n\u003cli\u003e论文不是很友好，但代码比较清晰；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n'}).add({id:2,href:"https://luoshi006.github.io/docs/learning/traj_planning/20210903_rt_traj_optimization_for_racing/",title:"RT Traj Optimization for Racing",description:"",content:'\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003erefs: \u003ca href="https://github.com/janismac/RacingTrajectoryOptimization"\u003ehttps://github.com/janismac/RacingTrajectoryOptimization\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-03_19-49.png" title="image" alt="racer sim" width="300"/\u003e\n\u003c/div\u003e\n\u003ch2 id="summary"\u003eSummary\u003c/h2\u003e\n\u003cp\u003e以赛道场景，构建了 QP 问题，求解在赛道上可行的轨迹。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eQP 问题要求问题是线性的，且可行域是凸集；文章比较详细的介绍了线性化操作及构建凸集的方法；\u003c/li\u003e\n\u003cli\u003e可借鉴的东西有限，但是作为入门很不错；\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="术语"\u003e术语\u003c/h2\u003e\n\u003ch3 id="坐标系"\u003e坐标系\u003c/h3\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-04_12-13.png" title="image" alt="frame" width="400"/\u003e\n\u003c/div\u003e\n\u003cp\u003e   $x,y$      Global 坐标系 \u003cbr\u003e\n   $\\xi, \\eta$       Body 坐标系 \u003cbr\u003e\n   $\\psi$       Yaw angle \u003cbr\u003e\n   $[a_{long}, a_{lat}]$   Body 系 加速度 \u003cbr\u003e\n   $u = [a_x, a_y]$   Global 系 加速度 \u003cbr\u003e\u003c/p\u003e\n\u003ch3 id="model"\u003eModel\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e在轨迹规划中，使用质心模型，只考虑质点加速度，能够使轨迹规划成为一个 \u003cstrong\u003e线性优化\u003c/strong\u003e 问题；\u003c/li\u003e\n\u003cli\u003e在自动驾驶场景中，汽车的控制通常由油门、方向盘、刹车实现。油门仅提供正向加速度；刹车提供减速度；方向盘改变前轮转向，从而将纵向加速度映射到横向。为方便控制，在 Tracking 过程中，分别实现了横纵向控制器。\u003c/li\u003e\n\u003cli\u003e轨迹优化中，需要考虑加速度限制。尤其是高速行驶过程中的空气影响。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="model-predictive-control"\u003eModel Predictive Control\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e给定被控系统模型和输入，预测未来时刻的系统状态；\u003c/li\u003e\n\u003cli\u003e离散模型按 时间步长 迭代，就可以得到一段离散轨迹；\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="race-track-model"\u003eRace Track Model\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e赛道模型由\u003cstrong\u003e中心线\u003c/strong\u003e $C$ 和 \u003cstrong\u003e赛道区域\u003c/strong\u003e $T$ 组成；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-04_23-01.png" title="image" alt="race" width="400"/\u003e\n\u003c/div\u003e\n\u003ch3 id="progress-function-进度"\u003eprogress function 进度\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e找到与车辆位置最近的 \u003cstrong\u003e中心线点\u003c/strong\u003e，return 从起点到当前 中心线点的弧长；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-04_23-17.png" title="image" alt="race" width="400"/\u003e\n\u003c/div\u003e\n\u003ch3 id="approximate-solutions"\u003eApproximate Solutions\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e优化问题通常是非凸的，轨迹优化中最常见的非凸约束是非凸的\u003cstrong\u003e可行区域\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-05_00-00.png" title="image" alt="race" width="200"  style="float: left; margin: 0 20px 10px 0"/\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSequential Convex Programming\u003c/strong\u003e \u003cbr\u003e\n\u0026ndash; Guess 初值 \u003cbr\u003e\n\u0026ndash; 在初值附近构造 QP 问题，求解局部最优解；\u003cbr\u003e\n\u0026ndash; 逐步迭代，直到解满足条件\u003cbr\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003c/p\u003e\n\u003ch2 id="trajectory-optimization-using-sequential-linearization"\u003eTrajectory Optimization using Sequential Linearization\u003c/h2\u003e\n\u003ch3 id="sequential-linearization"\u003eSequential Linearization\u003c/h3\u003e\n\u003cp\u003e用于快速找到轨迹规划的近似解。虽然常规的优化算法会一直运行到 \u003cem\u003e满足某个收敛条件\u003c/em\u003e 为止，但是在 QP 求解轨迹问题时，通常只执行几次就足以获得一个较好的解。\u003c/p\u003e\n\u003ch3 id="加速度约束"\u003e加速度约束\u003c/h3\u003e\n\u003cp\u003e原始的加速度约束是由两个椭球曲线定义的。但由于 QP 问题要求约束为 \u003cstrong\u003e线性等式或不等式\u003c/strong\u003e，所以需要对加速度约束进行线性化。由凸球变为凸多边形：\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-05_00-43.png" title="image" alt="race" width="400"  /\u003e\n\u003c/div\u003e\n图中，为了限制优化问题的大小，使用 16 条切线围成一个凸多边形；为了确定凸多边形的内部，需要为每条切线定义法线方向；\n\u003ch3 id="race-track-model-1"\u003eRace Track Model\u003c/h3\u003e\n\u003ch4 id="linear-approximation-of-the-track-boundaries"\u003eLinear Approximation of the Track Boundaries\u003c/h4\u003e\n\u003cp\u003e为构造 QP 问题的线性约束，赛道模型需要使用一组线性约束近似。文章中使用 \u003ccode\u003eTrajectory Point\u003c/code\u003e 处的切线（虚线）近似。\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-03_19-49.png" title="image" alt="racer sim" width="300"/\u003e\n\u003c/div\u003e\n\u003cp\u003e当最终的解与线性化点位置越近时，线性逼近越准确；所以 SL 迭代是渐进稳定的。\u003c/p\u003e\n\u003cp\u003e在轨迹采样时，通常将道路区域简化为中心线两侧的等宽轨道，$T_{L,j}, T_{R,j}, T_{C,j}$ 表示赛道左侧、右侧和中心线的点； $f_j, n_j$ 表示轨迹点前向、左侧的单位向量：\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-06_10-49.png" title="image" alt="racer sim" width="300"/\u003e\n\u003c/div\u003e\n\u003cp\u003e初始化点质量较差、或非线性比较严重时，当前点会出现在轨道约束范围之外。可以引入松弛变量（\u003ccode\u003eslack variable\u003c/code\u003e）软化约束；将约束条件转化为 \u003ccode\u003eCost\u003c/code\u003e，通过优化的梯度保证非严格约束；\u003c/p\u003e\n\u003ch4 id="trust-region"\u003eTrust Region\u003c/h4\u003e\n\u003cp\u003e为防止初始点偏差，引起的线性近似误差太大，从而导致不收敛的问题。引入 \u003ccode\u003eTrust Region\u003c/code\u003e ，将最终结果限制在初值附近，边长为 L 的正方形内\u003c/p\u003e\n\u003ch4 id="progress-function"\u003eProgress Function\u003c/h4\u003e\n\u003cp\u003e文章中代价主要表示为 progress function，所以也需要线性化。\u003c/p\u003e\n\u003ch3 id="trajectory-optimization-problem"\u003eTrajectory Optimization Problem\u003c/h3\u003e\n\u003cp\u003e参考论文 3.3\u003c/p\u003e\n\u003ch2 id="trajectory-optimization-using-sequential-convex-restriction"\u003eTrajectory Optimization using Sequential Convex Restriction\u003c/h2\u003e\n\u003ch3 id="race-track-model-2"\u003eRace Track Model\u003c/h3\u003e\n\u003ch4 id="track-tessellation"\u003eTrack Tessellation\u003c/h4\u003e\n\u003cp\u003e在赛道中心线上采样，并找到左右边界点；相邻的边界点串联得到细分的赛道范围；\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-09_18-39.png" title="image" alt="track tessellation" width="300"/\u003e\n\u003c/div\u003e\n\u003ch4 id="merging-polygons"\u003eMerging Polygons\u003c/h4\u003e\n\u003cp\u003e对相邻区域能够组成凸集的，合并；\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-09_18-42.png" title="image" alt="Merge race" width="300"/\u003e\n\u003c/div\u003e\n\u003ch4 id="overlaps"\u003eOverlaps\u003c/h4\u003e\n\u003cp\u003e扩展重叠区域\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-09_18-44.png" title="image" alt="Merge race" width="300"/\u003e\n\u003c/div\u003e\n建立与轨迹点对应的最大凸包序列（重叠区域未显示）\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-09_18-45.png" title="image" alt="Merge race2" width="300"/\u003e\n\u003c/div\u003e\n\u003cp\u003e运动过程中，找到的线性化点对应的凸包\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-06_19-37.png" title="image" alt="scr convex" width="300"/\u003e\n\u003c/div\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSCR 部分未详细阅读，代码结构相对比较清晰，有缘待续吧。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStephen Boyd. \u003ca href="https://stanford.edu/class/ee364b/lectures/seq_slides.pdf"\u003eSequential convex programming\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e对于 \u003ccode\u003eSequential Convex Restriction\u003c/code\u003e 的可行域图画的比较好： \u003csmall\u003e\u003cu\u003e\u003ci\u003eFeasible Path Identification in Optimal Power Flowwith Sequential Convex Restriction\u003c/i\u003e\u003c/u\u003e\u003c/small\u003e\u003c/li\u003e\n\u003cli\u003eROS 中机械臂轨迹库中的轨迹优化： \u003ca href="https://ros-planning.github.io/moveit_tutorials/doc/trajopt_planner/trajopt_planner_tutorial.html"\u003eMoveIt - TrajOpt\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'}).add({id:3,href:"https://luoshi006.github.io/docs/learning/traj_planning/20210916_optimal_traj_in_frenet_frame/",title:"Optimal Trajectory in a Frenet Frame",description:"",content:'\u003chr\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eOptimal Trajectory Generation for Dynamic Street Scenarios in a Frenet Frame\u003c/li\u003e\n\u003cli\u003eLocal Path Planning and Motion Control for AGV in Positioning\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href="https://github.com/ChenBohan/Robotics-Path-Planning-04-Quintic-Polynomial-Solver.git"\u003ehttps://github.com/ChenBohan/Robotics-Path-Planning-04-Quintic-Polynomial-Solver.git\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id="summary"\u003eSummary\u003c/h2\u003e\n\u003cp\u003e常见的轨迹规划算法，想要得到最优轨迹，通常都需要动态障碍物的精确模型。文章中提出的是一种基于采样的反应式轨迹生成算法。根据路宽、速度范围、预测时间范围\u003cstrong\u003e采样\u003c/strong\u003e得到 \u003cb\u003e\u003cfont color="999999"\u003e大量轨迹\u003c/font\u003e\u003c/b\u003e，删除不可行轨迹后，根据\u003cstrong\u003e代价\u003c/strong\u003e进行排序，选择 \u003cb\u003e\u003cfont color="FF0000"\u003e最优轨迹\u003c/font\u003e\u003c/b\u003e 执行。\u003c/p\u003e\n\u003cp\u003e【注】代码比论文好懂\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/frenet.gif" title="image" alt="frenet" width="600"/\u003e\n\u003c/div\u003e\n\u003ch2 id="keypoints"\u003eKeyPoints\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e采样频率的影响\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e过低的采样频率可能引起超调（下）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/overshoot.png" title="image" alt="frenet-overshoot" width="400"/\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eFrenet 坐标系\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e对于轨迹上一点 reference，以 切线方向 $\\vec{t}_r$ 和法线方向 $\\vec{n}_x$ 建立坐标系；$d(t)$ 表示机器人偏离轨迹的距离，$s(t)$ 表示机器人行程。\u003cbr\u003e\n图中，$\\vec{t}_x, \\vec{n}_x$ 仅用于表示机器人在 Frenet 坐标系的位姿；\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/frenet.png" title="image" alt="frenet-overshoot" width="300"/\u003e\n\u003c/div\u003e\n\u003ch2 id="frenet-流程"\u003eFrenet 流程\u003c/h2\u003e\n\u003ch3 id="lateral-movement"\u003eLateral Movement\u003c/h3\u003e\n\u003cp\u003e起始状态 $[d_0, \\dot{d_0}, \\ddot{d_0}]$，沿用上一状态，保证运动连续性；\n目标状态要求 $\\dot{d_1} = \\ddot{d_1} = 0$，以保证最终的沿线运动，即，\u003c/p\u003e\n\u003cp\u003e$$[d_1, \\dot{d_1}, \\ddot{d_1}, T]_{ij} = [d_i, 0, 0, T_j]$$\u003c/p\u003e\n\u003cp\u003e对采样空间中的 $i, j$ 分别采样，得到 Frenet 坐标系的\u003cstrong\u003e横向运动轨迹集\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3 id="longitudinal-movement"\u003eLongitudinal Movement\u003c/h3\u003e\n\u003cp\u003e起始状态 $[s_1, \\dot{s_1}, \\ddot{s_1}]$ ；\u003c/p\u003e\n\u003cp\u003e根据场景和当前状态，对不同的目标状态采样：\n$$[s_1, \\dot{s_1}, \\ddot{s_1}, T]_{ij} = [ [s_1(T_j)+\\Delta s_i], \\dot{s}_1(T_j), \\ddot{s}_1(T_j), T_j ]$$\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eFollow 跟随前车\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e根据交通规则和前车 [leader] 状态\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMerging 汇入车流\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e目标点在前、后两车的中间\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eStopping 停车\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e$s_{target} = s_{stop}$\u003c/li\u003e\n\u003cli\u003e$\\dot{s_t} = 0, \\ddot{s_t} = 0$\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVelocity Keeping 定速巡航\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e只对速度、加速度约束求解\u003c/li\u003e\n\u003cli\u003e$[\\dot{s_1}, \\ddot{s_1}, T]_{ij} = [[\\dot{s_d} + \\Delta \\dot{s_i}], 0, T_j]$\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="combining-lateral--longitudinal-trajectories"\u003eCombining Lateral \u0026amp; Longitudinal Trajectories\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e对 $T_{lat}$ 和  $T_{lon}$ 分别检查加速度，需注意保留部分加速能力，保证控制裕度\n\u003cul\u003e\n\u003cli\u003e同时需要为 \u003cem\u003e巡线\u003c/em\u003e 预留横向加速能力，因此需要保证目标轨迹的曲率上限；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e在笛卡尔坐标系，检查曲率是否超限，检查是否碰撞；\u003c/li\u003e\n\u003cli\u003e不引入障碍物的启发代价，从而避免复杂的参数调整\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="appendix-i"\u003eAppendix I\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFrenet coordinates -\u0026gt; Global coordinates\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e$$[s, \\dot{s}, \\ddot{s}; d, \\dot{d}, \\ddot{d}/d, d\', d\'\'] \\mapsto [\\vec{x}, \\theta_x, \\kappa_x, v_x, a_x]$$\u003c/p\u003e\n\u003cp\u003e其中，$\\dot{d} = \\frac{d}{dt}d$ ，$d\' = \\frac{d}{ds}d$\u003c/p\u003e\n\u003cp\u003e一通复杂的转换，两个坐标系之间主要通过机器人\u003cstrong\u003e行程\u003c/strong\u003e $s$ 实现转换；所以，坐标转换是离散采样实现的。轨迹的\u003cstrong\u003e非线性\u003c/strong\u003e对转换精度影响比较大。\u003c/p\u003e\n\u003ch3 id="appendix-ii"\u003eAppendix II\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e已知首尾状态，求解 四阶、五阶多项式\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id="quintic-polynomial"\u003eQuintic Polynomial\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e五次多项式\u003c/strong\u003e 标准形式：\u003c/p\u003e\n\u003cp\u003e$$ s(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 + a_5 t^5$$\u003c/p\u003e\n\u003cp\u003e已知，起始状态 $ t=0$ 时的状态，即\n$$\n\\begin{aligned}\na_0 \u0026amp;= s_0  \\newline\na_1 \u0026amp;= \\dot{s}_0 \\newline\na_2 \u0026amp;= \\frac{\\ddot{s}_0}{2} \\newline\n\\end{aligned}\n$$\n代入标准形式，得到终点 $t=T$ 的状态：\n$$\n\\begin{aligned}\ns_T \u0026amp;= s_0 + \\dot{s_0}T + \\frac{\\ddot{s}_0}{2}T^2 + a_3 T^3 +a_4 T^4 +a_5 T^5 \\newline\n\\dot{s}_T \u0026amp;= \\dot{s}_0 + \\ddot{s}_0 T + 3 a_3 T^2 + 4 a_4 T^3 + 5 a_5 T^4\\newline\n\\ddot{s}_T \u0026amp;= \\ddot{s}_0 + 5 a_3 T + 12 a_4 T^2 + 20 a_5 T^3 \\newline\n\\end{aligned}\n$$\n整理，\n$$\n\\begin{aligned}\na_3 T^3 +a_4 T^4 +a_5 T^5 \u0026amp;= s_T - s_0 - \\dot{s_0}T - \\frac{\\ddot{s}_0}{2}T^2 \\newline\n3 a_3 T^2 + 4 a_4 T^3 + 5 a_5 T^4 \u0026amp;= \\dot{s}_T - \\dot{s}_0 - \\ddot{s}_0 T \\newline\n5 a_3 T + 12 a_4 T^2 + 20 a_5 T^3 \u0026amp;= \\ddot{s}_T - \\ddot{s}_0  \\newline\n\\end{aligned}\n$$\u003c/p\u003e\n\u003cp\u003e写成矩阵形式\n$$\n\\begin{aligned}\na_3 T^3 +a_4 T^4 +a_5 T^5 \u0026amp;= s_T - s_0 - \\dot{s_0}T - \\frac{\\ddot{s}_0}{2}T^2 \\newline\n3 a_3 T^2 + 4 a_4 T^3 + 5 a_5 T^4 \u0026amp;= \\dot{s}_T - \\dot{s}_0 - \\ddot{s}_0 T \\newline\n5 a_3 T + 12 a_4 T^2 + 20 a_5 T^3 \u0026amp;= \\ddot{s}_T - \\ddot{s}_0  \\newline\n\\end{aligned}\n$$\u003c/p\u003e\n\u003cp\u003e矩阵形式：\u003c/p\u003e\n\u003cp\u003e$$ \\left[ \\begin{matrix} T^3 \u0026amp; T^4 \u0026amp; T^5 \\\\  3T^2 \u0026amp; 4T^3 \u0026amp; 5T^4 \\\\  6T \u0026amp; 12T^2 \u0026amp; 20 T^3\\end{matrix} \\right]   \\left[ \\begin{matrix} a_3 \\\\ a_4 \\\\ a_5 \\end{matrix} \\right]  =  \\left[ \\begin{matrix} s_T - s_0 - \\dot{s_0}T - \\frac{\\ddot{s}_0}{2}T^2 \\\\ \\dot{s}_T - \\dot{s}_0 - \\ddot{s}_0 T \\\\ \\ddot{s}_T - \\ddot{s}_0 \\end{matrix} \\right] $$\u003c/p\u003e\n\u003cp\u003e通过矩阵求逆，可以得到 $[a_3, a_4, a_5]$\u003c/p\u003e\n\u003ch4 id="quartic-polynomial"\u003eQuartic Polynomial\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e四阶多项式\u003c/strong\u003e 标准形式：\n$$ s(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 $$\u003c/p\u003e\n\u003cp\u003e同理\n$$\n\\begin{aligned}\na_0 \u0026amp;= s_0  \\newline\na_1 \u0026amp;= \\dot{s}_0 \\newline\na_2 \u0026amp;= \\frac{\\ddot{s}_0}{2} \\newline\n\\end{aligned}\n$$\n末端状态：\n$$\n\\begin{aligned}\n\\dot{s}_T \u0026amp;= \\dot{s}_0 + \\ddot{s}_0 T + 3 a_3 T^2 + 4 a_4 T^3 \\newline\n\\ddot{s}_T \u0026amp;= \\ddot{s}_0 + 5 a_3 T + 12 a_4 T^2 \\newline\n\\end{aligned}\n$$\u003c/p\u003e\n\u003cp\u003e矩阵形式：\n$$ \\left[ \\begin{matrix} 3T^2 \u0026amp; 4T^3  \\\\  6T \u0026amp; 12T^2 \\end{matrix} \\right]   \\left[ \\begin{matrix} a_3 \\\\ a_4  \\end{matrix} \\right]  =  \\left[ \\begin{matrix}  \\dot{s}_T - \\dot{s}_0 - \\ddot{s}_0 T \\\\ \\ddot{s}_T - \\ddot{s}_0 \\end{matrix} \\right] $$\n解得 $[a_3, a_4]$。\u003c/p\u003e\n\u003ch2 id="测试"\u003e测试\u003c/h2\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/frenet_all.gif" title="image" alt="frenet" width="600"/\u003e\n\u003c/div\u003e\n\u003cp\u003e增大 $T_i$ 采样范围\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/frenet_enlarge_dt.gif" title="image" alt="frenet" width="600"/\u003e\n\u003c/div\u003e\n'}).add({id:4,href:"https://luoshi006.github.io/docs/learning/traj_planning/20210924_reactive_nonholonomic_traj_gen/",title:"Reactive Nonholonomic Traj Gen",description:"",content:'\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003eReactive Nonholonomic Trajectory Generation via Parametric Optimal Control  - - \u003cem\u003eAlonzo Kelly, Bryan Nagy\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="https://github.com/lrm2017/SpiralsTrajactory.git"\u003ehttps://github.com/lrm2017/SpiralsTrajactory.git\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="https://github.com/jsford/PolyTraj.git"\u003ehttps://github.com/jsford/PolyTraj.git\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href="https://github.com/berlala/Basic_SD_Algorithm.git"\u003ehttps://github.com/berlala/Basic_SD_Algorithm.git\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id="abstract"\u003eAbstract\u003c/h2\u003e\n\u003cp\u003e文章讨论了怎么实时生成一条轨迹，将轨迹问题建模成最优控制问题，进而转化为非线性优化问题。主要共享在于 \u003cstrong\u003e三阶曲率多项式\u003c/strong\u003e 的公式推导及求解。\u003c/p\u003e\n\u003cp\u003e注：第二章介绍最优控制部分没看懂，对求解不影响，忽略；\u003c/p\u003e\n\u003cp\u003e【Keywords】Polynomial \u003ca href="https://www.2dcurves.com/spiral/spiralps.html"\u003eSpirals\u003c/a\u003e , \u003ca href="https://zh.wikipedia.org/wiki/%E7%BE%8A%E8%A7%92%E8%9E%BA%E7%BA%BF"\u003eClothoids\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id="solution-using-polynomial-spirals"\u003eSolution Using Polynomial Spirals\u003c/h2\u003e\n\u003ch3 id="32-clothoids"\u003e3.2 Clothoids\u003c/h3\u003e\n\u003cp\u003e回旋曲线 定义其曲率为线性变化：\u003c/p\u003e\n\u003cp\u003e$$ \\kappa (s) = a + bs$$\u003c/p\u003e\n\u003ch3 id="33-polynomial-spirals"\u003e3.3 Polynomial Spirals\u003c/h3\u003e\n\u003cp\u003e场景：已知起始点和终点的状态，求一条曲线\u003c/p\u003e\n\u003cp\u003e将曲率表示为 n 阶多项式，用以满足端点的约束条件；\u003c/p\u003e\n\u003ch3 id="34-reduction-to-decoupled-quadratures"\u003e3.4 Reduction to Decoupled Quadratures\u003c/h3\u003e\n\u003cp\u003e多项式螺旋线可以通过封闭形式积分得到航向角 heading\u003c/p\u003e\n\u003cp\u003e$$\n\\begin{aligned}\n\\kappa(s)\u0026amp;=a+bs+cs^2+ds^3 \\newline\n\\theta(s)\u0026amp;=\\theta_0 + \\int \\kappa ds =\\theta_0 + as+ \\frac{bs^2}{2} + \\frac{cs^3}{3}+ \\frac{ds^4}{4}\n\\end{aligned}\n\\tag{1}\n$$\u003c/p\u003e\n\u003cp\u003e再对行程积分，[generalized Fresnel integrals 广义菲涅尔积分]\u003c/p\u003e\n\u003cp\u003e$$\n\\begin{aligned}\nx(s)\u0026amp;=x_0+\\int_0^s cos \\left[as+ \\frac{bs^2}{2} + \\frac{cs^3}{3}+ \\frac{ds^4}{4}  \\right] ds\\newline\ny(s)\u0026amp;=y_0+\\int_0^s sin \\left[as+ \\frac{bs^2}{2} + \\frac{cs^3}{3}+ \\frac{ds^4}{4}  \\right] ds\\newline\n\\end{aligned}\n$$\n所以，位置无法以 closed-form 形式求解。\u003c/p\u003e\n\u003ch3 id="-求解多项式"\u003e· 求解多项式\u003c/h3\u003e\n\u003ch4 id="-获取-abcd-初值"\u003e·· 获取 [a/b/c/d] 初值\u003c/h4\u003e\n\u003ch5 id="-查表"\u003e··· 查表\u003c/h5\u003e\n\u003cp\u003e参考： \u003ca href="https://github.com/berlala/Basic_SD_Algorithm/blob/master/Path_Generation/Sprial%20Path%20with%20Quintic%20Velocity/Support_Fcn/threeD_spiral_param.mat"\u003eBasic_SD_Algorithm/Path_Generation\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e在起点处建立坐标系，保证起点坐标 $[0,0,0]$，在给定的圆弧内查找最近 伪终点，从而得到一条近似的初值。\u003c/p\u003e\n\u003ch5 id="-固定一个参数求解"\u003e··· 固定一个参数求解\u003c/h5\u003e\n\u003cp\u003e参考：\u003ca href="https://blog.csdn.net/github_39582118/article/details/117754864?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.control\u0026amp;spm=1001.2101.3001.4242"\u003ehttps://blog.csdn.net/github_39582118\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e根据 $(1)$ 式定义可得\n$$\n\\begin{aligned}\n\\kappa(0)\u0026amp;=p_0 =\\kappa_0 ，\u0026lt;起点曲率\u0026gt;\\newline\n\\kappa(\\frac{s_f}{3})\u0026amp;=p_1 =\\kappa_0+\\frac{b}{3}s_f+\\frac{c}{9}{s_f}^2+\\frac{d}{27}{s_f}^3 \\newline\n\\kappa(\\frac{2s_f}{3})\u0026amp;=p_2 =\\kappa_0+\\frac{2b}{3}{s_f}+\\frac{4c}{9}{s_f}^2+\\frac{8d}{27}{s_f}^3 \\newline\n\\kappa(s_f)\u0026amp;=p_3 = \\kappa_0+bs_f+c{s_f}^2+d{s_f}^3 \\newline\n\\end{aligned}\n\\tag{2}\n$$\n借用 $Matlab$ 求解 $b, c, d$\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-matlab"\u003e% Ax = B\nclear all\nclose all\nclc\n\nsyms p0 p1 p2 p3 s qf\nB = [p1-p0; p2-p0; p3-p0]\ndisp(\' \')\nA = [s/3   , (s/3)^2   , (s/3)^3   ;\n     2*s/3 , (2*s/3)^2 , (2*s/3)^3 ;\n     s     , s^2       , s^3       ]\n\ndisp(\' \')\ndisp(\'solve: \')\ndisp(\' \')\nfun = linsolve(A,B);\n\npretty(fun)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e得到结果：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-matlab"\u003eB =\n p1 - p0\n p2 - p0\n p3 - p0\n\nA =\n[     s/3,     s^2/9,     s^3/27]\n[ (2*s)/3, (4*s^2)/9, (8*s^3)/27]\n[       s,       s^2,        s^3]\n\nsolve:\n\n/   11 p0 - 18 p1 + 9 p2 - 2 p3 \\\n| - --------------------------- |   [b]\n|               2 s             |\n|                               |\n|  (2 p0 - 5 p1 + 4 p2 - p3) 9  |\n|  ---------------------------  |   [c]\n|                 2             |\n|              2 s              |\n|                               |\n|    (p0 - 3 p1 + 3 p2 - p3) 9  |\n|  - -------------------------  |   [d]\n|                  3            |\n\\               2 s             /\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e令 $d=0$ ，同时根据 $(1)$ 式中末端角度，求解\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-matlab"\u003etheta = p0*s + fun(1)/2*s^2 + fun(2)/3*s^3;\n\ndisp(\' \')\n% pretty(theta)\n\np1_with_p2 = solve(theta==qf, p1);\n\np2_ans = solve(p0-3*p1_with_p2+3*p2-p3==0,p2);  % d = 0\n\np1_ans = -(4*qf - 5*p0*s - 15*p2_ans*s + 4*p3*s)/(12*s);\n\nb_ans = simplify(-(11*p0 - 18*p1_ans + 9*p2_ans - 2*p3)/(2*s));\nc_ans = simplify((9*(2*p0 - 5*p1_ans + 4*p2_ans - p3))/(2*s^2));\n\ndisp(\' \')\ndisp(\'solve b \u0026amp; c when set d=0\')\npretty(b_ans)\npretty(c_ans)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e得到 $b, c$ 的初值，其中 qf 表示 $\\theta_f-\\theta_0$ ：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class="language-matlab"\u003e  4 p0 s - 6 qf + 2 p3 s\n- ----------------------                  [b]\n             2\n            s\n\n3 p0 s - 6 qf + 3 p3 s\n----------------------                    [c]\n           3\n          s\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e求取初值的过程中，仅使用了已知的角度和曲率，所以位置误差应该比较随机。\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/reactive.png" title="image" alt="scr convex" width="500"/\u003e\n\u003c/div\u003e\n\u003ch3 id="other"\u003eOther\u003c/h3\u003e\n\u003cp\u003e因示例代码中牛顿迭代法收敛性不好，怀疑是初值或者非线性的影响。最终使用 Nelder Mead 方法收敛，所以这里不进行偏导的推导。\u003c/p\u003e\n'}).add({id:5,href:"https://luoshi006.github.io/docs/learning/spline/20210917_cubic_spline/",title:"Cubic Spline",description:"",content:'\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003erefs: \u003ca href="https://mathworld.wolfram.com/CubicSpline.html"\u003ehttps://mathworld.wolfram.com/CubicSpline.html\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003ecode: \u003ca href="https://github.com/ChenBohan/Robotics-Path-Planning-04-Quintic-Polynomial-Solver/blob/master/Optimal%20Trajectory%20in%20a%20Frenet%20Frame/cubic_spline_planner.py"\u003ehttps://github.com/ChenBohan/Robotics-Path-Planning-04-Quintic-Polynomial-Solver/cubic_spline_planner.py\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="https://mathworld.wolfram.com/images/eps-gif/CubicSpline_700.gif" title="image" alt="cubic_spline" width="300"/\u003e\n\u003c/div\u003e\n\u003ch2 id="summary"\u003eSummary\u003c/h2\u003e\n\u003cp\u003e三次样条曲线由分段三次多项式组成，样条曲线依次穿过控制点 $m$ 。\u003c/p\u003e\n\u003cp\u003e不同的边界条件可以产生各种样条； \u003cstrong\u003e\u0026ldquo;natural\u0026rdquo;\u003c/strong\u003e 三次样条：终点处的二阶导数置为 $0$ 。\u003c/p\u003e\n\u003ch2 id="flow"\u003eFlow\u003c/h2\u003e\n\u003cp\u003e对于一维的情况，给定 $n+1$ 个控制点 $(y_0, y_1, \u0026hellip; , y_n)$ [Bartels et al.]，第 $i$ 段曲线表示为：\u003c/p\u003e\n\u003cp\u003e$$ Y_i(t) = a_i + b_i t + c_i t^2 + d_i t^3$$\u003c/p\u003e\n\u003cp\u003e其中，$t \\in [0,1]$ ， $i=0, \u0026hellip;, n-1$\u003c/p\u003e\n\u003cp\u003e对于\u003cstrong\u003e三阶多项式\u003c/strong\u003e，构造如下方程组：\u003c/p\u003e\n\u003cp\u003e$$\n\\begin{aligned}\nY_i(0) \u0026amp;= y_i = a_i  \\newline\nY_i(1) \u0026amp;= y_{i+1} = a_i+b_i+c_i+d_i \\newline\nY\'_i(0) \u0026amp;= D_i = b_i \\newline\nY_i(1)\' \u0026amp;= D_{i + 1}=b_i+2 c_i +3 d_i \\newline\n\\end{aligned}\n$$\u003c/p\u003e\n\u003ch3 id="result"\u003eresult\u003c/h3\u003e\n\u003cp\u003e四个未知数，四个方程，求解可得第 $i$ 组分段曲线的参数：\u003c/p\u003e\n\u003cp\u003e$$\n\\begin{aligned}\na_i \u0026amp;= y_i \\tag{1} \\newline\nb_i \u0026amp;=  D_i \\newline\nc_i \u0026amp;= 3(y_{i+1}-y_i)-2D_i-D_{i+1}\\newline\nd_i \u0026amp;= 2(y_i-y_{i+1})+D_i+D_{i+1}\\newline\n\\end{aligned}\n$$\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id="求解-d_i"\u003e求解 $D_i$\u003c/h3\u003e\n\u003cp\u003e对于\u003cstrong\u003e分段曲线\u003c/strong\u003e，要求二阶导连续，则对于内部点：\u003c/p\u003e\n\u003cp\u003e$$\n\\begin{aligned}\nY_{i-1}(1) \u0026amp;= y_i \\newline\nY\'_{i-1}(1) \u0026amp;=Y\'_i(0) \\newline\nY_i(0) \u0026amp;= y_i \\newline\nY\'\'_{i-1}(1) \u0026amp;= Y\'\'_i(0) \\newline\n\\end{aligned}\n$$\u003c/p\u003e\n\u003cp\u003e对于端点：\u003c/p\u003e\n\u003cp\u003e$$Y_0(0) = y_0$$\u003c/p\u003e\n\u003cp\u003e$$Y_{n-1}(1)=y_n$$\u003c/p\u003e\n\u003cp\u003e$4(n-1)+2=4n-2$ 个方程，$4n$ 个未知数，所以仍需额外提供两个约束：\u003c/p\u003e\n\u003cp\u003e$$Y\'\'_0(0) = 0$$\u003c/p\u003e\n\u003cp\u003e$$Y\'\'_{n-1}(1) = 0$$\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e由以上公式，可以得到如下三对角系统（tridiagonal）\u003c/p\u003e\n\u003cp\u003e$$\\left[ \\begin{matrix} 2\u0026amp;1\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp; \\\\ 1\u0026amp;4\u0026amp;1\u0026amp;\u0026amp;\u0026amp;\u0026amp; \\\\ \u0026amp;1\u0026amp;4\u0026amp;1\u0026amp;\u0026amp;\u0026amp; \\\\ \u0026amp;\u0026amp;1\u0026amp;4\u0026amp;1\u0026amp;\u0026amp; \\\\ \u0026amp;\u0026amp;\u0026amp; \\ddots \u0026amp; \\ddots \u0026amp; \\ddots \u0026amp; \\\\ \u0026amp;\u0026amp;\u0026amp;\u0026amp;1\u0026amp;4\u0026amp;1 \\\\ \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;1\u0026amp;2 \\end{matrix}  \\right] \\left[\\begin{matrix} D_0\\\\D_1\\\\D_2\\\\D_3\\\\ \\ddots \\\\D_{n-1} \\\\ D_n \\end{matrix}\\right] = \\left[\\begin{matrix} 3(y_1-y_0)\\\\3(y_2-y_0)\\\\3(y_3-y_1)\\\\ \\ddots \\\\ 3(y_{n-1}-y_{n-3})\\\\3(y_n-y_{n-2}) \\\\ 3(y_n-y_{n-1})\\end{matrix}\\right]$$\u003c/p\u003e\n\u003cp\u003e如果曲线收尾相连，则\u003c/p\u003e\n\u003cp\u003e$$\\left[ \\begin{matrix} 4\u0026amp;1\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;1 \\\\ 1\u0026amp;4\u0026amp;1\u0026amp;\u0026amp;\u0026amp;\u0026amp; \\\\ \u0026amp;1\u0026amp;4\u0026amp;1\u0026amp;\u0026amp;\u0026amp; \\\\ \u0026amp;\u0026amp;1\u0026amp;4\u0026amp;1\u0026amp;\u0026amp; \\\\ \u0026amp;\u0026amp;\u0026amp; \\ddots \u0026amp; \\ddots \u0026amp; \\ddots \u0026amp; \\\\ \u0026amp;\u0026amp;\u0026amp;\u0026amp;1\u0026amp;4\u0026amp;1 \\\\1\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;1\u0026amp;4 \\end{matrix}  \\right] \\left[\\begin{matrix} D_0\\\\D_1\\\\D_2\\\\D_3\\\\ \\ddots \\\\D_{n-1} \\\\ D_n \\end{matrix}\\right] = \\left[\\begin{matrix} 3(y_1-y_n)\\\\3(y_2-y_0)\\\\3(y_3-y_1)\\\\ \\ddots \\\\ 3(y_{n-1}-y_{n-3})\\\\3(y_n-y_{n-2}) \\\\ 3(y_0-y_{n-1})\\end{matrix}\\right]$$\u003c/p\u003e\n\u003cp\u003e代入 \u003ca href="/docs/learning/spline/20210917_cubic_spline/#result"\u003eresult \u003c/a\u003e $(1)$ 式，可以得到 $a_i, b_i, c_i, d_i$ 四个 vector，通过行程求 $i$，取出对应三阶多项式求解。\u003c/p\u003e\n'}).add({id:6,href:"https://luoshi006.github.io/docs/reading/01_code_reading/",title:"Code Reading",description:"Code Reading.",content:'\u003ch2 id="null"\u003eNULL\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ehttps://github.com/AtsushiSakai/PythonRobotics\u003c/li\u003e\n\u003c/ul\u003e\n'}).add({id:7,href:"https://luoshi006.github.io/docs/reading/02_paper_reading/",title:"Paper Reading",description:"",content:"\u003cp\u003exxx\u003c/p\u003e\n"}).add({id:8,href:"https://luoshi006.github.io/docs/",title:"Docs",description:"Docs.",content:""}).add({id:9,href:"https://luoshi006.github.io/docs/learning/",title:"Learning",description:"learning.",content:""}).add({id:10,href:"https://luoshi006.github.io/docs/reading/",title:"Reading",description:"Reading page",content:""}),userinput.addEventListener('input',c,!0),suggestions.addEventListener('click',e,!0);function c(){var h=this.value,f=b.search(h,{limit:5,index:["content"],enrich:!0}),g=suggestions.childNodes,e=0,i=f.length,c;for(suggestions.classList.remove('d-none'),f.forEach(function(b){c=document.createElement('div'),c.innerHTML='<a href><span></span><span></span></a>',a=c.querySelector('a'),t=c.querySelector('span:first-child'),d=c.querySelector('span:nth-child(2)'),a.href=b.result[e].doc.href,t.textContent=b.result[e].doc.title,d.textContent=b.result[e].doc.description,suggestions.appendChild(c)});g.length>i;)suggestions.removeChild(g[e])}function e(){while(suggestions.lastChild)suggestions.removeChild(suggestions.lastChild);return!1}})()