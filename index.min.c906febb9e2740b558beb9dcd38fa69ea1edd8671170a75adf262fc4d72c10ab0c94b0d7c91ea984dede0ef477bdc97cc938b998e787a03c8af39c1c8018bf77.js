var suggestions=document.getElementById('suggestions'),userinput=document.getElementById('userinput');document.addEventListener('keydown',inputFocus);function inputFocus(a){a.keyCode===191&&(a.preventDefault(),userinput.focus()),a.keyCode===27&&(userinput.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(b){const d=suggestions.querySelectorAll('a'),e=[...d],a=e.indexOf(document.activeElement);let c=0;b.keyCode===38?(b.preventDefault(),c=a>0?a-1:0,d[c].focus()):b.keyCode===40&&(b.preventDefault(),c=a+1<e.length?a+1:a,d[c].focus())}(function(){var b=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:'id',store:["href","title","description"],index:["title","description","content"]}});b.add({id:0,href:"https://luoshi006.github.io/docs/learning/introduction/",title:"Introduction",description:"",content:'\u003ch2 id="learning"\u003eLearning\u003c/h2\u003e\n\u003cp\u003e记录学习过程\u0026hellip;.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/learning/traj_planning/20210903_traj_planning"\u003eTraj Planning\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'}).add({id:1,href:"https://luoshi006.github.io/docs/learning/traj_planning/20210903_traj_planning/",title:"Traj Planning",description:"",content:'\u003chr\u003e\n\u003ch2 id="traj-planning"\u003eTraj Planning\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/learning/traj_planning/20210903_rt_traj_optimization_for_racing"\u003eReal-time Trajectory Optimization for Autonomous Vehicle Racing\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e一篇本科论文，从汽车模型开始，介绍了怎么建模，构建 QP 问题，线性化处理；比较全面，且有代码示例；\u003c/li\u003e\n\u003cli\u003e因为里面涉及到比较多 \u003cstrong\u003e凸优化\u003c/strong\u003e 的知识，所以深入阅读有门槛；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n'}).add({id:2,href:"https://luoshi006.github.io/docs/learning/traj_planning/20210903_rt_traj_optimization_for_racing/",title:"RT Traj Optimization for Racing",description:"",content:'\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003erefs: \u003ca href="https://github.com/janismac/RacingTrajectoryOptimization"\u003ehttps://github.com/janismac/RacingTrajectoryOptimization\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-03_19-49.png" title="image" alt="racer sim" width="300"/\u003e\n\u003c/div\u003e\n\u003ch2 id="summary"\u003eSummary\u003c/h2\u003e\n\u003cp\u003e以赛道场景，构建了 QP 问题，求解在赛道上可行的轨迹。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eQP 问题要求问题是线性的，且可行域是凸集；文章比较详细的介绍了线性化操作及构建凸集的方法；\u003c/li\u003e\n\u003cli\u003e可借鉴的东西有限，但是作为入门很不错；\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="术语"\u003e术语\u003c/h2\u003e\n\u003ch3 id="坐标系"\u003e坐标系\u003c/h3\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-04_12-13.png" title="image" alt="frame" width="400"/\u003e\n\u003c/div\u003e\n\u003cp\u003e   $x,y$      Global 坐标系 \u003cbr\u003e\n   $\\xi, \\eta$       Body 坐标系 \u003cbr\u003e\n   $\\psi$       Yaw angle \u003cbr\u003e\n   $[a_{long}, a_{lat}]$   Body 系 加速度 \u003cbr\u003e\n   $u = [a_x, a_y]$   Global 系 加速度 \u003cbr\u003e\u003c/p\u003e\n\u003ch3 id="model"\u003eModel\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e在轨迹规划中，使用质心模型，只考虑质点加速度，能够使轨迹规划成为一个 \u003cstrong\u003e线性优化\u003c/strong\u003e 问题；\u003c/li\u003e\n\u003cli\u003e在自动驾驶场景中，汽车的控制通常由油门、方向盘、刹车实现。油门仅提供正向加速度；刹车提供减速度；方向盘改变前轮转向，从而将纵向加速度映射到横向。为方便控制，在 Tracking 过程中，分别实现了横纵向控制器。\u003c/li\u003e\n\u003cli\u003e轨迹优化中，需要考虑加速度限制。尤其是高速行驶过程中的空气影响。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="model-predictive-control"\u003eModel Predictive Control\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e给定被控系统模型和输入，预测未来时刻的系统状态；\u003c/li\u003e\n\u003cli\u003e离散模型按 时间步长 迭代，就可以得到一段离散轨迹；\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="race-track-model"\u003eRace Track Model\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e赛道模型由\u003cstrong\u003e中心线\u003c/strong\u003e $C$ 和 \u003cstrong\u003e赛道区域\u003c/strong\u003e $T$ 组成；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-04_23-01.png" title="image" alt="race" width="400"/\u003e\n\u003c/div\u003e\n\u003ch3 id="progress-function-进度"\u003eprogress function 进度\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e找到与车辆位置最近的 \u003cstrong\u003e中心线点\u003c/strong\u003e，return 从起点到当前 中心线点的弧长；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-04_23-17.png" title="image" alt="race" width="400"/\u003e\n\u003c/div\u003e\n\u003ch3 id="approximate-solutions"\u003eApproximate Solutions\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e优化问题通常是非凸的，轨迹优化中最常见的非凸约束是非凸的\u003cstrong\u003e可行区域\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-05_00-00.png" title="image" alt="race" width="200"  style="float: left; margin: 0 20px 10px 0"/\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSequential Convex Programming\u003c/strong\u003e \u003cbr\u003e\n\u0026ndash; Guess 初值 \u003cbr\u003e\n\u0026ndash; 在初值附近构造 QP 问题，求解局部最优解；\u003cbr\u003e\n\u0026ndash; 逐步迭代，直到解满足条件\u003cbr\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003c/p\u003e\n\u003ch2 id="trajectory-optimization-using-sequential-linearization"\u003eTrajectory Optimization using Sequential Linearization\u003c/h2\u003e\n\u003ch3 id="sequential-linearization"\u003eSequential Linearization\u003c/h3\u003e\n\u003cp\u003e用于快速找到轨迹规划的近似解。虽然常规的优化算法会一直运行到 \u003cem\u003e满足某个收敛条件\u003c/em\u003e 为止，但是在 QP 求解轨迹问题时，通常只执行几次就足以获得一个较好的解。\u003c/p\u003e\n\u003ch3 id="加速度约束"\u003e加速度约束\u003c/h3\u003e\n\u003cp\u003e原始的加速度约束是由两个椭球曲线定义的。但由于 QP 问题要求约束为 \u003cstrong\u003e线性等式或不等式\u003c/strong\u003e，所以需要对加速度约束进行线性化。由凸球变为凸多边形：\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-05_00-43.png" title="image" alt="race" width="400"  /\u003e\n\u003c/div\u003e\n图中，为了限制优化问题的大小，使用 16 条切线围成一个凸多边形；为了确定凸多边形的内部，需要为每条切线定义法线方向；\n\u003ch3 id="race-track-model-1"\u003eRace Track Model\u003c/h3\u003e\n\u003ch4 id="linear-approximation-of-the-track-boundaries"\u003eLinear Approximation of the Track Boundaries\u003c/h4\u003e\n\u003cp\u003e为构造 QP 问题的线性约束，赛道模型需要使用一组线性约束近似。文章中使用 \u003ccode\u003eTrajectory Point\u003c/code\u003e 处的切线（虚线）近似。\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-03_19-49.png" title="image" alt="racer sim" width="300"/\u003e\n\u003c/div\u003e\n\u003cp\u003e当最终的解与线性化点位置越近时，线性逼近越准确；所以 SL 迭代是渐进稳定的。\u003c/p\u003e\n\u003cp\u003e在轨迹采样时，通常将道路区域简化为中心线两侧的等宽轨道，$T_{L,j}, T_{R,j}, T_{C,j}$ 表示赛道左侧、右侧和中心线的点； $f_j, n_j$ 表示轨迹点前向、左侧的单位向量：\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-06_10-49.png" title="image" alt="racer sim" width="300"/\u003e\n\u003c/div\u003e\n\u003cp\u003e初始化点质量较差、或非线性比较严重时，当前点会出现在轨道约束范围之外。可以引入松弛变量（\u003ccode\u003eslack variable\u003c/code\u003e）软化约束；将约束条件转化为 \u003ccode\u003eCost\u003c/code\u003e，通过优化的梯度保证非严格约束；\u003c/p\u003e\n\u003ch4 id="trust-region"\u003eTrust Region\u003c/h4\u003e\n\u003cp\u003e为防止初始点偏差，引起的线性近似误差太大，从而导致不收敛的问题。引入 \u003ccode\u003eTrust Region\u003c/code\u003e ，将最终结果限制在初值附近，边长为 L 的正方形内\u003c/p\u003e\n\u003ch4 id="progress-function"\u003eProgress Function\u003c/h4\u003e\n\u003cp\u003e文章中代价主要表示为 progress function，所以也需要线性化。\u003c/p\u003e\n\u003ch3 id="trajectory-optimization-problem"\u003eTrajectory Optimization Problem\u003c/h3\u003e\n\u003cp\u003e参考论文 3.3\u003c/p\u003e\n\u003ch2 id="trajectory-optimization-using-sequential-convex-restriction"\u003eTrajectory Optimization using Sequential Convex Restriction\u003c/h2\u003e\n\u003ch3 id="race-track-model-2"\u003eRace Track Model\u003c/h3\u003e\n\u003ch4 id="track-tessellation"\u003eTrack Tessellation\u003c/h4\u003e\n\u003cp\u003e在赛道中心线上采样，并找到左右边界点；相邻的边界点串联得到细分的赛道范围；\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-09_18-39.png" title="image" alt="track tessellation" width="300"/\u003e\n\u003c/div\u003e\n\u003ch4 id="merging-polygons"\u003eMerging Polygons\u003c/h4\u003e\n\u003cp\u003e对相邻区域能够组成凸集的，合并；\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-09_18-42.png" title="image" alt="Merge race" width="300"/\u003e\n\u003c/div\u003e\n\u003ch4 id="overlaps"\u003eOverlaps\u003c/h4\u003e\n\u003cp\u003e扩展重叠区域\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-09_18-44.png" title="image" alt="Merge race" width="300"/\u003e\n\u003c/div\u003e\n建立与轨迹点对应的最大凸包序列（重叠区域未显示）\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-09_18-45.png" title="image" alt="Merge race2" width="300"/\u003e\n\u003c/div\u003e\n\u003cp\u003e运动过程中，找到的线性化点对应的凸包\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-06_19-37.png" title="image" alt="scr convex" width="300"/\u003e\n\u003c/div\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSCR 部分未详细阅读，代码结构相对比较清晰，有缘待续吧。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStephen Boyd. \u003ca href="https://stanford.edu/class/ee364b/lectures/seq_slides.pdf"\u003eSequential convex programming\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e对于 \u003ccode\u003eSequential Convex Restriction\u003c/code\u003e 的可行域图画的比较好： \u003csmall\u003e\u003cu\u003e\u003ci\u003eFeasible Path Identification in Optimal Power Flowwith Sequential Convex Restriction\u003c/i\u003e\u003c/u\u003e\u003c/small\u003e\u003c/li\u003e\n\u003cli\u003eROS 中机械臂轨迹库中的轨迹优化： \u003ca href="https://ros-planning.github.io/moveit_tutorials/doc/trajopt_planner/trajopt_planner_tutorial.html"\u003eMoveIt - TrajOpt\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'}).add({id:3,href:"https://luoshi006.github.io/docs/learning/traj_planning/20210916_optimal_traj_in_frenet_frame/",title:"Optimal Trajectory in a Frenet Frame",description:"",content:'\u003chr\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eOptimal Trajectory Generation for Dynamic Street Scenarios in a Frenet Frame\u003c/li\u003e\n\u003cli\u003eLocal Path Planning and Motion Control for AGV in Positioning\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href="https://github.com/ChenBohan/Robotics-Path-Planning-04-Quintic-Polynomial-Solver.git"\u003ehttps://github.com/ChenBohan/Robotics-Path-Planning-04-Quintic-Polynomial-Solver.git\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id="summary"\u003eSummary\u003c/h2\u003e\n\u003cp\u003e常见的轨迹规划算法，想要得到最优轨迹，通常都需要动态障碍物的精确模型。文章中提出的是一种基于采样的反应式轨迹生成算法。根据路宽、速度范围、预测时间范围\u003cstrong\u003e采样\u003c/strong\u003e得到 \u003cb\u003e\u003cfont color="999999"\u003e大量轨迹\u003c/font\u003e\u003c/b\u003e，删除不可行轨迹后，根据\u003cstrong\u003e代价\u003c/strong\u003e进行排序，选择 \u003cb\u003e\u003cfont color="FF0000"\u003e最优轨迹\u003c/font\u003e\u003c/b\u003e 执行。\u003c/p\u003e\n\u003cp\u003e【注】代码比论文好懂\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/frenet.gif" title="image" alt="frenet" width="600"/\u003e\n\u003c/div\u003e\n\u003ch2 id="todo"\u003eTODO\u003c/h2\u003e\n\u003cp\u003e未读懂的点\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled="" type="checkbox"\u003e Bellman’s principle\n\u003cul\u003e\n\u003cli\u003e\u003cinput disabled="" type="checkbox"\u003e 动态规划最优算法\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cinput disabled="" type="checkbox"\u003e quintic_polynomial\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="keypoints"\u003eKeyPoints\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e采样频率的影响\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e过低的采样频率可能引起超调（下）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/overshoot.png" title="image" alt="frenet-overshoot" width="400"/\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eFrenet 坐标系\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e对于轨迹上一点 reference，以 切线方向 $\\vec{t}_r$ 和法线方向 $\\vec{n}_x$ 建立坐标系；$d(t)$ 表示机器人偏离轨迹的距离，$s(t)$ 表示机器人行程。\u003cbr\u003e\n图中，$\\vec{t}_x, \\vec{n}_x$ 仅用于表示机器人在 Frenet 坐标系的位姿；\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/frenet.png" title="image" alt="frenet-overshoot" width="300"/\u003e\n\u003c/div\u003e\n\u003ch2 id="frenet-流程"\u003eFrenet 流程\u003c/h2\u003e\n\u003ch3 id="lateral-movement"\u003eLateral Movement\u003c/h3\u003e\n\u003cp\u003e起始状态 $[d_0, \\dot{d_0}, \\ddot{d_0}]$，沿用上一状态，保证运动连续性；\n目标状态要求 $\\dot{d_1} = \\ddot{d_1} = 0$，以保证最终的沿线运动，即，\u003c/p\u003e\n\u003cp\u003e$$[d_1, \\dot{d_1}, \\ddot{d_1}, T]_{ij} = [d_i, 0, 0, T_j]$$\u003c/p\u003e\n\u003cp\u003e对采样空间中的 $i, j$ 分别采样，得到 Frenet 坐标系的\u003cstrong\u003e横向运动轨迹集\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3 id="longitudinal-movement"\u003eLongitudinal Movement\u003c/h3\u003e\n\u003cp\u003e起始状态 $[s_1, \\dot{s_1}, \\ddot{s_1}]$ ；\u003c/p\u003e\n\u003cp\u003e根据场景和当前状态，对不同的目标状态采样：\n$$[s_1, \\dot{s_1}, \\ddot{s_1}, T]_{ij} = [ [s_1(T_j)+\\Delta s_i], \\dot{s}_1(T_j), \\ddot{s}_1(T_j), T_j ]$$\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eFollow 跟随前车\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e根据交通规则和前车 [leader] 状态\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMerging 汇入车流\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e目标点在前、后两车的中间\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eStopping 停车\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e$s_{target} = s_{stop}$\u003c/li\u003e\n\u003cli\u003e$\\dot{s_t} = 0, \\ddot{s_t} = 0$\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVelocity Keeping 定速巡航\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e只对速度、加速度约束求解\u003c/li\u003e\n\u003cli\u003e$[\\dot{s_1}, \\ddot{s_1}, T]_{ij} = [[\\dot{s_d} + \\Delta \\dot{s_i}], 0, T_j]$\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="combining-lateral--longitudinal-trajectories"\u003eCombining Lateral \u0026amp; Longitudinal Trajectories\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e对 $T_{lat}$ 和  $T_{lon}$ 分别检查加速度，需注意保留部分加速能力，保证控制裕度\n\u003cul\u003e\n\u003cli\u003e同时需要为 \u003cem\u003e巡线\u003c/em\u003e 预留横向加速能力，因此需要保证目标轨迹的曲率上限；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e在笛卡尔坐标系，检查曲率是否超限，检查是否碰撞；\u003c/li\u003e\n\u003cli\u003e不引入障碍物的启发代价，从而避免复杂的参数调整\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="appendix"\u003eAppendix\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFrenet coordinates -\u0026gt; Global coordinates\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e$$[s, \\dot{s}, \\ddot{s}; d, \\dot{d}, \\ddot{d}/d, d\', d\'\'] \\mapsto [\\vec{x}, \\theta_x, \\kappa_x, v_x, a_x]$$\u003c/p\u003e\n\u003cp\u003e其中，$\\dot{d} = \\frac{d}{dt}d$ ，$d\' = \\frac{d}{ds}d$\u003c/p\u003e\n\u003cp\u003e一通复杂的转换，两个坐标系之间主要通过机器人\u003cstrong\u003e行程\u003c/strong\u003e $s$ 实现转换；所以，坐标转换是离散采样实现的。轨迹的\u003cstrong\u003e非线性\u003c/strong\u003e对转换精度影响比较大。\u003c/p\u003e\n\u003ch2 id="测试"\u003e测试\u003c/h2\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/frenet_all.gif" title="image" alt="frenet" width="600"/\u003e\n\u003c/div\u003e\n\u003cp\u003e增大 $T_i$ 采样范围\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/frenet_enlarge_dt.gif" title="image" alt="frenet" width="600"/\u003e\n\u003c/div\u003e\n'}).add({id:4,href:"https://luoshi006.github.io/docs/learning/spline/20210917_cubic_spline/",title:"Cubic Spline",description:"",content:'\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003erefs: \u003ca href="https://mathworld.wolfram.com/CubicSpline.html"\u003ehttps://mathworld.wolfram.com/CubicSpline.html\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003ecode: \u003ca href="https://github.com/ChenBohan/Robotics-Path-Planning-04-Quintic-Polynomial-Solver/blob/master/Optimal%20Trajectory%20in%20a%20Frenet%20Frame/cubic_spline_planner.py"\u003ehttps://github.com/ChenBohan/Robotics-Path-Planning-04-Quintic-Polynomial-Solver/cubic_spline_planner.py\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="https://mathworld.wolfram.com/images/eps-gif/CubicSpline_700.gif" title="image" alt="cubic_spline" width="300"/\u003e\n\u003c/div\u003e\n\u003ch2 id="summary"\u003eSummary\u003c/h2\u003e\n\u003cp\u003e三次样条曲线由分段三次多项式组成，样条曲线依次穿过控制点 $m$ 。\u003c/p\u003e\n\u003cp\u003e不同的边界条件可以产生各种样条； \u003cstrong\u003e\u0026ldquo;natural\u0026rdquo;\u003c/strong\u003e 三次样条：终点处的二阶导数置为 $0$ 。\u003c/p\u003e\n\u003ch2 id="flow"\u003eFlow\u003c/h2\u003e\n\u003cp\u003e对于一维的情况，给定 $n+1$ 个控制点 $(y_0, y_1, \u0026hellip; , y_n)$ [Bartels et al.]，第 $i$ 段曲线表示为：\u003c/p\u003e\n\u003cp\u003e$$ Y_i(t) = a_i + b_i t + c_i t^2 + d_i t^3$$\u003c/p\u003e\n\u003cp\u003e其中，$t \\in [0,1]$ ， $i=0, \u0026hellip;, n-1$\u003c/p\u003e\n\u003cp\u003e对于\u003cstrong\u003e三阶多项式\u003c/strong\u003e，构造如下方程组：\u003c/p\u003e\n\u003cp\u003e$$\n\\begin{aligned}\nY_i(0) \u0026amp;= y_i = a_i  \\newline\nY_i(1) \u0026amp;= y_{i+1} = a_i+b_i+c_i+d_i \\newline\nY\'_i(0) \u0026amp;= D_i = b_i \\newline\nY_i(1)\' \u0026amp;= D_{i + 1}=b_i+2 c_i +3 d_i \\newline\n\\end{aligned}\n$$\u003c/p\u003e\n\u003ch3 id="result"\u003eresult\u003c/h3\u003e\n\u003cp\u003e四个未知数，四个方程，求解可得第 $i$ 组分段曲线的参数：\u003c/p\u003e\n\u003cp\u003e$$\n\\begin{aligned}\na_i \u0026amp;= y_i \\tag{1} \\newline\nb_i \u0026amp;=  D_i \\newline\nc_i \u0026amp;= 3(y_{i+1}-y_i)-2D_i-D_{i+1}\\newline\nd_i \u0026amp;= 2(y_i-y_{i+1})+D_i+D_{i+1}\\newline\n\\end{aligned}\n$$\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id="求解-d_i"\u003e求解 $D_i$\u003c/h3\u003e\n\u003cp\u003e对于\u003cstrong\u003e分段曲线\u003c/strong\u003e，要求二阶导连续，则对于内部点：\u003c/p\u003e\n\u003cp\u003e$$\n\\begin{aligned}\nY_{i-1}(1) \u0026amp;= y_i \\newline\nY\'_{i-1}(1) \u0026amp;=Y\'_i(0) \\newline\nY_i(0) \u0026amp;= y_i \\newline\nY\'\'_{i-1}(1) \u0026amp;= Y\'\'_i(0) \\newline\n\\end{aligned}\n$$\u003c/p\u003e\n\u003cp\u003e对于端点：\u003c/p\u003e\n\u003cp\u003e$$Y_0(0) = y_0$$\u003c/p\u003e\n\u003cp\u003e$$Y_{n-1}(1)=y_n$$\u003c/p\u003e\n\u003cp\u003e$4(n-1)+2=4n-2$ 个方程，$4n$ 个未知数，所以仍需额外提供两个约束：\u003c/p\u003e\n\u003cp\u003e$$Y\'\'_0(0) = 0$$\u003c/p\u003e\n\u003cp\u003e$$Y\'\'_{n-1}(1) = 0$$\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e由以上公式，可以得到如下三对角系统（tridiagonal）\u003c/p\u003e\n\u003cp\u003e$$\\left[ \\begin{matrix} 2\u0026amp;1\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp; \\\\ 1\u0026amp;4\u0026amp;1\u0026amp;\u0026amp;\u0026amp;\u0026amp; \\\\ \u0026amp;1\u0026amp;4\u0026amp;1\u0026amp;\u0026amp;\u0026amp; \\\\ \u0026amp;\u0026amp;1\u0026amp;4\u0026amp;1\u0026amp;\u0026amp; \\\\ \u0026amp;\u0026amp;\u0026amp; \\ddots \u0026amp; \\ddots \u0026amp; \\ddots \u0026amp; \\\\ \u0026amp;\u0026amp;\u0026amp;\u0026amp;1\u0026amp;4\u0026amp;1 \\\\ \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;1\u0026amp;2 \\end{matrix}  \\right] \\left[\\begin{matrix} D_0\\\\D_1\\\\D_2\\\\D_3\\\\ \\ddots \\\\D_{n-1} \\\\ D_n \\end{matrix}\\right] = \\left[\\begin{matrix} 3(y_1-y_0)\\\\3(y_2-y_0)\\\\3(y_3-y_1)\\\\ \\ddots \\\\ 3(y_{n-1}-y_{n-3})\\\\3(y_n-y_{n-2}) \\\\ 3(y_n-y_{n-1})\\end{matrix}\\right]$$\u003c/p\u003e\n\u003cp\u003e如果曲线收尾相连，则\u003c/p\u003e\n\u003cp\u003e$$\\left[ \\begin{matrix} 4\u0026amp;1\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;1 \\\\ 1\u0026amp;4\u0026amp;1\u0026amp;\u0026amp;\u0026amp;\u0026amp; \\\\ \u0026amp;1\u0026amp;4\u0026amp;1\u0026amp;\u0026amp;\u0026amp; \\\\ \u0026amp;\u0026amp;1\u0026amp;4\u0026amp;1\u0026amp;\u0026amp; \\\\ \u0026amp;\u0026amp;\u0026amp; \\ddots \u0026amp; \\ddots \u0026amp; \\ddots \u0026amp; \\\\ \u0026amp;\u0026amp;\u0026amp;\u0026amp;1\u0026amp;4\u0026amp;1 \\\\1\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;1\u0026amp;4 \\end{matrix}  \\right] \\left[\\begin{matrix} D_0\\\\D_1\\\\D_2\\\\D_3\\\\ \\ddots \\\\D_{n-1} \\\\ D_n \\end{matrix}\\right] = \\left[\\begin{matrix} 3(y_1-y_n)\\\\3(y_2-y_0)\\\\3(y_3-y_1)\\\\ \\ddots \\\\ 3(y_{n-1}-y_{n-3})\\\\3(y_n-y_{n-2}) \\\\ 3(y_0-y_{n-1})\\end{matrix}\\right]$$\u003c/p\u003e\n\u003cp\u003e代入 \u003ca href="/docs/learning/spline/20210917_cubic_spline/#result"\u003eresult \u003c/a\u003e $(1)$ 式，可以得到 $a_i, b_i, c_i, d_i$ 四个 vector，通过行程求 $i$，取出对应三阶多项式求解。\u003c/p\u003e\n'}).add({id:5,href:"https://luoshi006.github.io/docs/reading/01_code_reading/",title:"Code Reading",description:"Code Reading.",content:'\u003ch2 id="null"\u003eNULL\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ehttps://github.com/AtsushiSakai/PythonRobotics\u003c/li\u003e\n\u003c/ul\u003e\n'}).add({id:6,href:"https://luoshi006.github.io/docs/reading/02_paper_reading/",title:"Paper Reading",description:"",content:"\u003cp\u003exxx\u003c/p\u003e\n"}).add({id:7,href:"https://luoshi006.github.io/docs/",title:"Docs",description:"Docs.",content:""}).add({id:8,href:"https://luoshi006.github.io/docs/learning/",title:"Learning",description:"learning.",content:""}).add({id:9,href:"https://luoshi006.github.io/docs/reading/",title:"Reading",description:"Reading page",content:""}),userinput.addEventListener('input',c,!0),suggestions.addEventListener('click',e,!0);function c(){var h=this.value,f=b.search(h,{limit:5,index:["content"],enrich:!0}),g=suggestions.childNodes,e=0,i=f.length,c;for(suggestions.classList.remove('d-none'),f.forEach(function(b){c=document.createElement('div'),c.innerHTML='<a href><span></span><span></span></a>',a=c.querySelector('a'),t=c.querySelector('span:first-child'),d=c.querySelector('span:nth-child(2)'),a.href=b.result[e].doc.href,t.textContent=b.result[e].doc.title,d.textContent=b.result[e].doc.description,suggestions.appendChild(c)});g.length>i;)suggestions.removeChild(g[e])}function e(){while(suggestions.lastChild)suggestions.removeChild(suggestions.lastChild);return!1}})()