var suggestions=document.getElementById('suggestions'),userinput=document.getElementById('userinput');document.addEventListener('keydown',inputFocus);function inputFocus(a){a.keyCode===191&&(a.preventDefault(),userinput.focus()),a.keyCode===27&&(userinput.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(b){const d=suggestions.querySelectorAll('a'),e=[...d],a=e.indexOf(document.activeElement);let c=0;b.keyCode===38?(b.preventDefault(),c=a>0?a-1:0,d[c].focus()):b.keyCode===40&&(b.preventDefault(),c=a+1<e.length?a+1:a,d[c].focus())}(function(){var b=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:'id',store:["href","title","description"],index:["title","description","content"]}});b.add({id:0,href:"https://luoshi006.github.io/docs/learning/introduction/",title:"Introduction",description:"",content:'\u003ch2 id="learning"\u003eLearning\u003c/h2\u003e\n\u003cp\u003e记录学习过程\u0026hellip;.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/learning/traj_planning/20210903_traj_planning"\u003eTraj Planning\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'}).add({id:1,href:"https://luoshi006.github.io/docs/learning/traj_planning/20210903_traj_planning/",title:"Traj Planning",description:"",content:'\u003chr\u003e\n\u003ch2 id="traj-planning"\u003eTraj Planning\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href="/docs/learning/traj_planning/20210903_rt_traj_optimization_for_racing"\u003eReal-time Trajectory Optimization for Autonomous Vehicle Racing\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e一篇本科论文，从汽车模型开始，介绍了怎么建模，构建 QP 问题，线性化处理；比较全面，且有代码示例；\u003c/li\u003e\n\u003cli\u003e因为里面涉及到比较多 \u003cstrong\u003e凸优化\u003c/strong\u003e 的知识，所以深入阅读有门槛；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n'}).add({id:2,href:"https://luoshi006.github.io/docs/learning/traj_planning/20210903_rt_traj_optimization_for_racing/",title:"RT Traj Optimization for Racing",description:"",content:'\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003erefs: \u003ca href="https://github.com/janismac/RacingTrajectoryOptimization"\u003ehttps://github.com/janismac/RacingTrajectoryOptimization\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-03_19-49.png" title="image" alt="racer sim" width="300"/\u003e\n\u003c/div\u003e\n\u003ch2 id="summary"\u003eSummary\u003c/h2\u003e\n\u003cp\u003e以赛道场景，构建了 QP 问题，求解在赛道上可行的轨迹。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eQP 问题要求问题是线性的，且可行域是凸集；文章比较详细的介绍了线性化操作及构建凸集的方法；\u003c/li\u003e\n\u003cli\u003e可借鉴的东西有限，但是作为入门很不错；\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id="术语"\u003e术语\u003c/h2\u003e\n\u003ch3 id="坐标系"\u003e坐标系\u003c/h3\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-04_12-13.png" title="image" alt="frame" width="400"/\u003e\n\u003c/div\u003e\n\u003cp\u003e   $x,y$      Global 坐标系 \u003cbr\u003e\n   $\\xi, \\eta$       Body 坐标系 \u003cbr\u003e\n   $\\psi$       Yaw angle \u003cbr\u003e\n   $[a_{long}, a_{lat}]$   Body 系 加速度 \u003cbr\u003e\n   $u = [a_x, a_y]$   Global 系 加速度 \u003cbr\u003e\u003c/p\u003e\n\u003ch3 id="model"\u003eModel\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e在轨迹规划中，使用质心模型，只考虑质点加速度，能够使轨迹规划成为一个 \u003cstrong\u003e线性优化\u003c/strong\u003e 问题；\u003c/li\u003e\n\u003cli\u003e在自动驾驶场景中，汽车的控制通常由油门、方向盘、刹车实现。油门仅提供正向加速度；刹车提供减速度；方向盘改变前轮转向，从而将纵向加速度映射到横向。为方便控制，在 Tracking 过程中，分别实现了横纵向控制器。\u003c/li\u003e\n\u003cli\u003e轨迹优化中，需要考虑加速度限制。尤其是高速行驶过程中的空气影响。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="model-predictive-control"\u003eModel Predictive Control\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e给定被控系统模型和输入，预测未来时刻的系统状态；\u003c/li\u003e\n\u003cli\u003e离散模型按 时间步长 迭代，就可以得到一段离散轨迹；\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id="race-track-model"\u003eRace Track Model\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e赛道模型由\u003cstrong\u003e中心线\u003c/strong\u003e $C$ 和 \u003cstrong\u003e赛道区域\u003c/strong\u003e $T$ 组成；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-04_23-01.png" title="image" alt="race" width="400"/\u003e\n\u003c/div\u003e\n\u003ch3 id="progress-function-进度"\u003eprogress function 进度\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e找到与车辆位置最近的 \u003cstrong\u003e中心线点\u003c/strong\u003e，return 从起点到当前 中心线点的弧长；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-04_23-17.png" title="image" alt="race" width="400"/\u003e\n\u003c/div\u003e\n\u003ch3 id="approximate-solutions"\u003eApproximate Solutions\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e优化问题通常是非凸的，轨迹优化中最常见的非凸约束是非凸的\u003cstrong\u003e可行区域\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-05_00-00.png" title="image" alt="race" width="200"  style="float: left; margin: 0 20px 10px 0"/\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSequential Convex Programming\u003c/strong\u003e \u003cbr\u003e\n\u0026ndash; Guess 初值 \u003cbr\u003e\n\u0026ndash; 在初值附近构造 QP 问题，求解局部最优解；\u003cbr\u003e\n\u0026ndash; 逐步迭代，直到解满足条件\u003cbr\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003c/p\u003e\n\u003ch2 id="trajectory-optimization-using-sequential-linearization"\u003eTrajectory Optimization using Sequential Linearization\u003c/h2\u003e\n\u003ch3 id="sequential-linearization"\u003eSequential Linearization\u003c/h3\u003e\n\u003cp\u003e用于快速找到轨迹规划的近似解。虽然常规的优化算法会一直运行到 \u003cem\u003e满足某个收敛条件\u003c/em\u003e 为止，但是在 QP 求解轨迹问题时，通常只执行几次就足以获得一个较好的解。\u003c/p\u003e\n\u003ch3 id="加速度约束"\u003e加速度约束\u003c/h3\u003e\n\u003cp\u003e原始的加速度约束是由两个椭球曲线定义的。但由于 QP 问题要求约束为 \u003cstrong\u003e线性等式或不等式\u003c/strong\u003e，所以需要对加速度约束进行线性化。由凸球变为凸多边形：\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-05_00-43.png" title="image" alt="race" width="400"  /\u003e\n\u003c/div\u003e\n图中，为了限制优化问题的大小，使用 16 条切线围成一个凸多边形；为了确定凸多边形的内部，需要为每条切线定义法线方向；\n\u003ch3 id="race-track-model-1"\u003eRace Track Model\u003c/h3\u003e\n\u003ch4 id="linear-approximation-of-the-track-boundaries"\u003eLinear Approximation of the Track Boundaries\u003c/h4\u003e\n\u003cp\u003e为构造 QP 问题的线性约束，赛道模型需要使用一组线性约束近似。文章中使用 \u003ccode\u003eTrajectory Point\u003c/code\u003e 处的切线（虚线）近似。\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-03_19-49.png" title="image" alt="racer sim" width="300"/\u003e\n\u003c/div\u003e\n\u003cp\u003e当最终的解与线性化点位置越近时，线性逼近越准确；所以 SL 迭代是渐进稳定的。\u003c/p\u003e\n\u003cp\u003e在轨迹采样时，通常将道路区域简化为中心线两侧的等宽轨道，$T_{L,j}, T_{R,j}, T_{C,j}$ 表示赛道左侧、右侧和中心线的点； $f_j, n_j$ 表示轨迹点前向、左侧的单位向量：\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-06_10-49.png" title="image" alt="racer sim" width="300"/\u003e\n\u003c/div\u003e\n\u003cp\u003e初始化点质量较差、或非线性比较严重时，当前点会出现在轨道约束范围之外。可以引入松弛变量（\u003ccode\u003eslack variable\u003c/code\u003e）软化约束；将约束条件转化为 \u003ccode\u003eCost\u003c/code\u003e，通过优化的梯度保证非严格约束；\u003c/p\u003e\n\u003ch4 id="trust-region"\u003eTrust Region\u003c/h4\u003e\n\u003cp\u003e为防止初始点偏差，引起的线性近似误差太大，从而导致不收敛的问题。引入 \u003ccode\u003eTrust Region\u003c/code\u003e ，将最终结果限制在初值附近，边长为 L 的正方形内\u003c/p\u003e\n\u003ch4 id="progress-function"\u003eProgress Function\u003c/h4\u003e\n\u003cp\u003e文章中代价主要表示为 progress function，所以也需要线性化。\u003c/p\u003e\n\u003ch3 id="trajectory-optimization-problem"\u003eTrajectory Optimization Problem\u003c/h3\u003e\n\u003cp\u003e参考论文 3.3\u003c/p\u003e\n\u003ch2 id="trajectory-optimization-using-sequential-convex-restriction"\u003eTrajectory Optimization using Sequential Convex Restriction\u003c/h2\u003e\n\u003ch3 id="race-track-model-2"\u003eRace Track Model\u003c/h3\u003e\n\u003ch4 id="track-tessellation"\u003eTrack Tessellation\u003c/h4\u003e\n\u003cp\u003e在赛道中心线上采样，并找到左右边界点；相邻的边界点串联得到细分的赛道范围；\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-09_18-39.png" title="image" alt="track tessellation" width="300"/\u003e\n\u003c/div\u003e\n\u003ch4 id="merging-polygons"\u003eMerging Polygons\u003c/h4\u003e\n\u003cp\u003e对相邻区域能够组成凸集的，合并；\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-09_18-42.png" title="image" alt="Merge race" width="300"/\u003e\n\u003c/div\u003e\n\u003ch4 id="overlaps"\u003eOverlaps\u003c/h4\u003e\n\u003cp\u003e扩展重叠区域\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-09_18-44.png" title="image" alt="Merge race" width="300"/\u003e\n\u003c/div\u003e\n建立与轨迹点对应的最大凸包序列（重叠区域未显示）\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-09_18-45.png" title="image" alt="Merge race2" width="300"/\u003e\n\u003c/div\u003e\n\u003cp\u003e运动过程中，找到的线性化点对应的凸包\u003c/p\u003e\n\u003cdiv align="center"\u003e\n\u003cimg src="/docs/learning/traj_planning/images/2021-09-06_19-37.png" title="image" alt="scr convex" width="300"/\u003e\n\u003c/div\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSCR 部分未详细阅读，代码结构相对比较清晰，有缘待续吧。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStephen Boyd. \u003ca href="https://stanford.edu/class/ee364b/lectures/seq_slides.pdf"\u003eSequential convex programming\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e对于 \u003ccode\u003eSequential Convex Restriction\u003c/code\u003e 的可行域图画的比较好： \u003csmall\u003e\u003cu\u003e\u003ci\u003eFeasible Path Identification in Optimal Power Flowwith Sequential Convex Restriction\u003c/i\u003e\u003c/u\u003e\u003c/small\u003e\u003c/li\u003e\n\u003cli\u003eROS 中机械臂轨迹库中的轨迹优化： \u003ca href="https://ros-planning.github.io/moveit_tutorials/doc/trajopt_planner/trajopt_planner_tutorial.html"\u003eMoveIt - TrajOpt\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n'}).add({id:3,href:"https://luoshi006.github.io/docs/reading/01_code_reading/",title:"Code Reading",description:"Code Reading.",content:'\u003ch2 id="null"\u003eNULL\u003c/h2\u003e\n'}).add({id:4,href:"https://luoshi006.github.io/docs/reading/02_paper_reading/",title:"Paper Reading",description:"",content:"\u003cp\u003exxx\u003c/p\u003e\n"}).add({id:5,href:"https://luoshi006.github.io/docs/",title:"Docs",description:"Docs.",content:""}).add({id:6,href:"https://luoshi006.github.io/docs/learning/",title:"Learning",description:"learning.",content:""}).add({id:7,href:"https://luoshi006.github.io/docs/reading/",title:"Reading",description:"Reading page",content:""}),userinput.addEventListener('input',c,!0),suggestions.addEventListener('click',e,!0);function c(){var h=this.value,f=b.search(h,{limit:5,index:["content"],enrich:!0}),g=suggestions.childNodes,e=0,i=f.length,c;for(suggestions.classList.remove('d-none'),f.forEach(function(b){c=document.createElement('div'),c.innerHTML='<a href><span></span><span></span></a>',a=c.querySelector('a'),t=c.querySelector('span:first-child'),d=c.querySelector('span:nth-child(2)'),a.href=b.result[e].doc.href,t.textContent=b.result[e].doc.title,d.textContent=b.result[e].doc.description,suggestions.appendChild(c)});g.length>i;)suggestions.removeChild(g[e])}function e(){while(suggestions.lastChild)suggestions.removeChild(suggestions.lastChild);return!1}})()